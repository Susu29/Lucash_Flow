# LucashFlow  
  
 Video Demo : https://youtu.be/NN2FYprlB-g

## Description

### Introduction  
  
Lucashflow is a small accounting software built with Django (Python) & PostgreSQL, covering transactions, ledger, balance, and financial statements.  
As a quick resume, it registers SQL tables for Accounts, Customers, Suppliers & Transactions. Users are able to create, modify & delete those following French accounting rules.  
  
From those data, it is possible to edit a list of transactions, a ledger, a balance, an income statement and a balance sheet. The income statements & balance sheets are financial documents. So I had to map the accounts into their respective categories.  
  
A transaction is divided into two parts : The header (name, date, invoice) & the lines (account, amounts, debit/credit). A transaction must be composed of two lines. So each line gets a foreign key linked to the transaction.  
  
Actually, the logic for verifying a transaction was the hardest part to implement, as it needs atomic validation of different forms.   
  
There’s a table called AccountsLink that acts as a link table between the customers, suppliers & accounts. As the customers do have an account field that’s fairly similar to the regular account formats. However, they need by nature other fields than accounting accounts (mail, address..). So it’s a table that has 4 columns, 3 for the foreign keys, one for the account name (much easier to query and sort).  
  
For many templates, I’ve used the library DataTables to present neatly my data. Why? Because it has integrated sorting, filtering etc… and I didn’t want to spend too long on JavaScript as it is not my priority.  
  
Front-end aesthetic has been made with HTML, CSS & Bootstrap5. Fairly basic but a navbar seems to render very well in my opinion.  
  
The program follows Django logic which is kinda opinionated. It also follows Django pattern : MVT - Model/View/Template. I will go more in detail about those.  
  
  
### Presentation of the files :   
  
Some descriptions might feel a bit short, but I don’t really want to completely explain how Django works as I think I should focus on the documents I’ve really modified and not just inputted a line of settings. A lot of files are pre-created by Django.  
  
Also, the file might already be long enough without going into too much detail.  
  
For the most curious, there’s a good introduction to Django on this page: [https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Django/Introduction](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Django/Introduction)  
  
manage.py: Django internal file, called to use commands and communicate through the framework.   
Folder Lucash: Basically, all the files inside it are generated by Django. Not so much to see. Some settings had to be configured, and that’s nearly all.  
The only important point to say is that the PostgreSQL DB connection has been configured in settings.py.  
  
<u>Folder accounting:</u> That’s where the programme has been written.  
   
__init__.py: Internal to Django  
Admin.py: Links the models to Django administration  
apps.py: Internal to Django, just had to configure the name of the app  
Tests.py: Created by Django, unused  
Models.py: Here reside all the SQL tables and relations. (Except some SQL triggers). Basically, the whole DB model is written in this file. It doesn’t hold a lot of logic except some basic verifications.  
Views.py: This page redirects to the appropriate templates, giving the templates some data issued from the models. There’s a bit of verification involved for the transactions, as they need multiple forms to be valid.   
Urls.py: Uses views to attribute URLs to each template.  
Forms.py: This is where the Add/Update/Delete functions are treated and passed to the templates.   
helpers.py: Makes the aggregates reusable through all the views. Basically makes the query reusable as they are by default limited to their own views.  
  
  
<u>Accounting Subfolder: Data</u>  
  
This folder covers the sample data made by ChatGPT (Customers, Accounts Chart (PCG), Suppliers & Transactions). Writing myself a whole accounting sample would just be too long.  
  
There’s a small pcg_conversion.py file in the PCG folder that applies some modifications to the CSV file using Pandas.  
  
In transactions, there’s my prompt text file, as well as a file named sample_verification.py. Made with Pandas, it contains multiple tests to verify that the files given by ChatGPT respect the accounting standard. (Spoiler: They didn’t until a long amount of prompts.)  
  
<u>Accounting Subfolder: db_backup</u>  
  
Well, it contains only one file and this one is explicit, just a SQL file to recreate the DB.  
  
<u>Accounting Subfolder: management</u>  
  
A mixture of intern to Django and custom scripts to import the CSV data sample into the DB. (customers_to_sql, pcg_send_to_sql, suppliers_to_sql, transactions_to_sql)  
  
<u>Accounting Subfolder: migrations</u>  
  
Intern to Django, this describes the model history and progression. Basically, after modifying the models (= database model), you have to “migrate” it to the actual DB. It translates Django/Python language into SQL. Every single file reflects my models, so there’s not that much to see, except for the file 0009_auto_20260111_1407.py, which was made manually to insert some SQL triggers into the DB.  
  
<u>Accounting Subfolder: static</u>  
  
This one hosts the files for CSS, Bootstrap, the LucashFlow logo, and the DataTables & its jQuery dependency. Nothing fancy, just some imports of libraries.   
  
<u>Accounting Subfolder: templates</u>  
  
This folder is one of the most important ones. Each template represents a webpage. Although some are reused through some variables.  
I know some templates could be factorised into one, but as the number of templates stays relatively limited for now, I don’t consider it a priority.  
  
How does it work ? The values of the templates get passed by the views.py file. If there’s a form, the views.py passes the form into the template.  
  
General:   
  
master.html: The template that is reused on each other one. Import the library & contains the layout of the website (basically the blue navbar).  
faq.html: A “text” page with some information about the project. It’s a ReadMe.  
home.html: A kind of dashboard with a list of aggregates.  
  
List views:  
  
accounts.html: Displays all the accounts through a DataTable table. There are buttons to add, create, and delete accounts.  
thirdparty.html : Display Customers OR Suppliers through a DataTable table. Showing customers or suppliers depends on the variable passed to the template. There are buttons to add, create, delete third party.  
transactions_header :  Display all the transaction header through a DataTable table. There are buttons to add, create, delete account.  
ledger : Basically the same but with the lines. Also includes a few pieces of information from the header.  
  
Aggregate views / Financial Statements :  
  
balance.html : Aggregate the amount of debit/query for each account and display them in a DataTable table.  
income_statement.html : An important financial document. It’s a table where the data is queried from the helpers.py doc.  
balance_sheet.html : An important financial document. It’s a table where the data is queried from the helpers.py. This one was hard to make as it required some precise mapping.  
  
Add/Update/Delete templates :   
  
add_accounts.html, add_thirdparty.html :  Display the fields of the form on an HTML template. Which then gets posted to the DB.  
Same for update & delete templates, at the exception that they are preceded by select_accounts, select_thirdparty to give the primary key to the URL to know which deleted or updated account is chosen.  
  
  
add_transactions, delete_transactions: Display the fields of multiple forms on an HTML template. Which then gets posted to the DB.   
select : same as described above.  
update_transactions : Specificity as the ID (Primary Key) needs to be included as a hidden field in the form, as it is automatically managed by Django. If the ID is not present, then Django doesn’t know which line is relied upon for the header. As it is received but not resent.  
  
  
### Usage of AI  
  
AI has been used like a tutor, but mostly like an enhanced Google. Its usage has been limited.By querying Google, the AI Overview greatly helped me save time browsing multiple websites.Basically, it gave me more examples that Django documentation often lacks.  
  
Cases where I relied on ChatGPT:
  
Logo:  
The logo was made using ChatGPT.  
  
Sample database:  
The sample database was made using ChatGPT, as creating it manually would have been very tedious.Following the file, I have made a script verifying the integrity of the CSV given.The script has proven to be useful as I had to modify the prompt numerous times.  
  
CSS / layout:  
Since CSS beyond the basics was not a priority, I’ve asked for a lot of help on how to adjust the tables as they are subject to a lot of misalignment. I've however made the design myself, although it is very simple.  
  
Django InlineFormSet:  
Some guidance on the InLineFormSet as I didn’t find the documentation very explicit.  
  
